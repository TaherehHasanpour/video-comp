<template>
  <div class="uploader">
    <h2>Ø¢Ù¾Ù„ÙˆØ¯ Ùˆ ÙØ´Ø±Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¹Ú©Ø³ Ùˆ ÙˆÛŒØ¯Ø¦Ùˆ</h2>

    <!-- ÙØ§ÛŒÙ„ ÙˆØ±ÙˆØ¯ÛŒ -->
    <input
      ref="fileInput"
      type="file"
      multiple
      @change="onFileChange"
      accept="image/*,video/*"
      class="file-input"
    />

    <!-- ØªÙ†Ø¸ÛŒÙ…Ø§Øª ÙØ´Ø±Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ -->
    <div class="controls">
      <div class="control-item">
        <label>Ø­Ø¯Ø§Ú©Ø«Ø± Ø¹Ø±Ø¶ Ø¹Ú©Ø³ (px)</label>
        <input type="number" v-model.number="imageMaxWidth" />
      </div>
      <div class="control-item">
        <label>Ø­Ø¯Ø§Ú©Ø«Ø± Ø­Ø¬Ù… Ø¹Ú©Ø³ (MB)</label>
        <input step="0.1" type="number" v-model.number="imageMaxMB" />
      </div>
      <div class="control-item">
        <label>Ú©ÛŒÙÛŒØª Ø¹Ú©Ø³ (0.1-1)</label>
        <input step="0.1" type="number" v-model.number="imageQuality" />
      </div>
      <div class="control-item">
        <label>Ø±Ø²ÙˆÙ„ÙˆØ´Ù† Ù‡Ø¯Ù ÙˆÛŒØ¯Ø¦Ùˆ (px)</label>
        <input type="number" v-model.number="videoTargetWidth" />
      </div>
      <div class="control-item">
        <label>Ø¨ÛŒØªâ€ŒØ±ÛŒØª Ù‡Ø¯Ù ÙˆÛŒØ¯Ø¦Ùˆ (kbps)</label>
        <input type="number" v-model.number="videoTargetKbps" />
      </div>
    </div>

    <div class="actions">
      <button @click="processFiles" :disabled="processing || !items.length">
        ÙØ´Ø±Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ùˆ Ø§Ø¶Ø§ÙÙ‡ Ø¨Ù‡ FilePond
      </button>
      <button @click="clearAll" class="clear-btn">Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù‡Ù…Ù‡</button>
    </div>

    <pre v-if="lastResponse" class="server-response">
      Ù¾Ø§Ø³Ø® Ø³Ø±ÙˆØ±: {{ lastResponse }}
    </pre>

    <!-- FilePond Ù†Ù…Ø§ÛŒØ´ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ -->

    <file-pond
      ref="pond"
      name="file"
      label-idle="ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ Ø±Ø§ Ø§ÛŒÙ†Ø¬Ø§ Ø¨Ú©Ø´ÛŒØ¯ ÛŒØ§ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯"
      :allow-multiple="true"
      :server="serverOptions"
      :accepted-file-types="['image/*', 'video/*']"
      @processfile="onProcessFile"
      @processfileerror="onProcessFileError"
    />
  </div>
</template>
<script setup>
import { ref } from 'vue'
import imageCompression from 'browser-image-compression'

import vueFilePond from 'vue-filepond'

// Ù¾Ù„Ø§Ú¯ÛŒÙ†â€ŒÙ‡Ø§
import FilePondPluginFileValidateType from 'filepond-plugin-file-validate-type'
import FilePondPluginImagePreview from 'filepond-plugin-image-preview'

// Ø³Ø§Ø®Øª Ú©Ø§Ù…Ù¾ÙˆÙ†Ù†Øª FilePond
const FilePond = vueFilePond(FilePondPluginFileValidateType, FilePondPluginImagePreview)
const pond = ref(null)

// ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÙˆØ± ÙˆØ§Ù‚Ø¹ÛŒ
const serverOptions = {
  process: {
    url: 'https://httpbin.org/post', // Ø§ÛŒÙ†Ø¬Ø§ URL Ø³Ø±ÙˆØ± ÙˆØ§Ù‚Ø¹ÛŒ
    method: 'POST',
    withCredentials: false,
    headers: {},
  },
  revert: null,
  restore: null,
  load: null,
  fetch: null,
}

const onProcessFile = (error, file) => {
  if (error) {
    console.error('Upload failed', error)
  } else {
    console.log('Upload success', file.filename)
  }
}

const onProcessFileError = (error) => {
  console.error('Upload error', error)
}
// ----- Ù…ØªØºÛŒØ±Ù‡Ø§ -----
const fileInput = ref(null)
const items = ref([]) // ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨â€ŒØ´Ø¯Ù‡
const pondFiles = ref([]) // ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¢Ù…Ø§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ FilePond
const processing = ref(false)
const lastResponse = ref(null)

const acceptedFileTypes = ['image/*', 'video/*']
// const serverOptions = {
//   url: 'https://your-server.com/upload', // Ø¢Ø¯Ø±Ø³ Ø³Ø±ÙˆØ±
//   process: {
//     url: '/',
//     method: 'POST',
//     withCredentials: false,
//     headers: {},
//     onload: (response) => {
//       lastResponse.value = response
//       return response.key
//     },
//     onerror: (response) => {
//       console.error('Upload error', response)
//     },
//   },
// }

// ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù‚Ø§Ø¨Ù„ ØªØºÛŒÛŒØ±
const imageMaxWidth = ref(1920)
const imageMaxMB = ref(0.6)
const imageQuality = ref(0.75)
const videoTargetWidth = ref(1280)
const videoTargetKbps = ref(800) // kbps

// ----- ØªÙˆØ§Ø¨Ø¹ -----
function formatBytes(bytes) {
  if (bytes === 0) return '0 B'
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
}

function onFileChange(e) {
  const selected = Array.from(e.target.files || [])
  for (const f of selected) {
    const obj = {
      file: f,
      type: f.type,
      previewUrl: URL.createObjectURL(f),
      status: 'Ø¢Ù…Ø§Ø¯Ù‡',
      progress: 0,
      uploadedUrl: null,
      compressedUrl: null,
    }
    items.value.push(obj)
  }
}

function removeItem(idx) {
  const it = items.value[idx]
  URL.revokeObjectURL(it.previewUrl)
  if (it.compressedUrl) URL.revokeObjectURL(it.compressedUrl)
  items.value.splice(idx, 1)
}

function clearAll() {
  for (const it of items.value) {
    URL.revokeObjectURL(it.previewUrl)
    if (it.compressedUrl) URL.revokeObjectURL(it.compressedUrl)
  }
  items.value = []
  pondFiles.value = []
}

async function processFiles() {
  processing.value = true
  try {
    for (const it of items.value) {
      let processedFile = it.file

      if (it.type.startsWith('image/')) {
        try {
          processedFile = await compressImage(it.file)
          it.compressedUrl = URL.createObjectURL(processedFile)
          console.log(
            `ğŸ“‰ ØªØµÙˆÛŒØ± ${it.file.name} Ø¨Ø¹Ø¯ Ø§Ø² ÙØ´Ø±Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ: ${formatBytes(processedFile.size)}`,
          )
        } catch (err) {
          console.error('âŒ Ø®Ø·Ø§ Ø¯Ø± ÙØ´Ø±Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ ØªØµÙˆÛŒØ±', err)
        }
      } else if (it.type.startsWith('video/')) {
        try {
          const compressedVideoBlob = await compressVideo(it.file, {
            width: videoTargetWidth.value,
            kbps: videoTargetKbps.value,
          })
          processedFile = new File(
            [compressedVideoBlob],
            it.file.name.replace(/\.[^.]+$/, '.webm'),
            { type: compressedVideoBlob.type },
          )
          it.compressedUrl = URL.createObjectURL(compressedVideoBlob)
          console.log(
            `ğŸ“‰ ÙˆÛŒØ¯Ø¦Ùˆ ${it.file.name} Ø¨Ø¹Ø¯ Ø§Ø² ÙØ´Ø±Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ: ${formatBytes(processedFile.size)}`,
          )
        } catch (err) {
          console.error('âŒ Ø®Ø·Ø§ Ø¯Ø± ÙØ´Ø±Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ ÙˆÛŒØ¯Ø¦Ùˆ', err)
        }
      }

      // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¨Ù‡ FilePond
      pondFiles.value.push({
        source: processedFile,
        options: { type: 'local' },
      })
    }

    // Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† items Ø¨Ø¹Ø¯ Ø§Ø² Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù† Ø¨Ù‡ FilePond
    items.value = []
  } finally {
    processing.value = false
  }
}

// ------------------ Image compression ------------------
async function compressImage(file) {
  const options = {
    maxSizeMB: imageMaxMB.value,
    maxWidthOrHeight: imageMaxWidth.value,
    useWebWorker: true,
    initialQuality: imageQuality.value,
  }
  const compressedFile = await imageCompression(file, options)
  return compressedFile
}

// ------------------ Video compression ------------------
function compressVideo(file, { width = 1280, kbps = 800 } = {}) {
  return new Promise((resolve, reject) => {
    if (typeof MediaRecorder === 'undefined')
      return reject(new Error('MediaRecorder Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯'))

    const url = URL.createObjectURL(file)
    const video = document.createElement('video')
    video.src = url
    video.muted = true
    video.playsInline = true
    video.preload = 'auto'

    video.addEventListener(
      'loadedmetadata',
      async () => {
        try {
          const aspect = video.videoWidth / video.videoHeight
          const targetWidth = Math.min(width, video.videoWidth)
          const targetHeight = Math.round(targetWidth / aspect)

          const canvas = document.createElement('canvas')
          canvas.width = targetWidth
          canvas.height = targetHeight
          const ctx = canvas.getContext('2d')

          const fps = 25
          const stream = canvas.captureStream(fps)

          const mimeTypeCandidates = [
            'video/webm;codecs=vp9',
            'video/webm;codecs=vp8',
            'video/webm',
          ]
          const mimeType =
            mimeTypeCandidates.find(
              (m) => MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(m),
            ) || 'video/webm'

          const bitrate = kbps * 1000
          const options = { mimeType, videoBitsPerSecond: bitrate }

          const recordedChunks = []
          let mediaRecorder
          try {
            mediaRecorder = new MediaRecorder(stream, options)
          } catch (err) {
            reject(err)
            return
          }

          mediaRecorder.ondataavailable = (ev) => {
            if (ev.data && ev.data.size) recordedChunks.push(ev.data)
          }

          mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: mimeType })
            URL.revokeObjectURL(url)
            resolve(blob)
          }

          video.addEventListener('play', () => {
            mediaRecorder.start(1000)
            function draw() {
              if (video.paused || video.ended) {
                try {
                  mediaRecorder.stop()
                } catch {}
                return
              }
              ctx.drawImage(video, 0, 0, canvas.width, canvas.height)
              requestAnimationFrame(draw)
            }
            requestAnimationFrame(draw)
          })

          video.play().catch((err) => reject(err))
        } catch (err) {
          reject(err)
        }
      },
      { once: true },
    )

    video.addEventListener('error', () => reject(new Error('Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ÙˆÛŒØ¯Ø¦Ùˆ')))
  })
}
</script>
<style scoped>
.uploader {
  max-width: 500px;
  margin: 20px auto;
}
.uploader {
  max-width: 900px;
  margin: 2rem auto;
  padding: 1.5rem;
  border: 1px solid #ddd;
  border-radius: 10px;
  background: #fafafa;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
  font-family: 'Vazir', sans-serif;
}

h2 {
  text-align: center;
  margin-bottom: 1.5rem;
  color: #333;
}

.file-input {
  display: block;
  margin: 0 auto 1rem;
  padding: 0.5rem;
  border-radius: 6px;
  border: 1px solid #ccc;
  width: 100%;
  max-width: 400px;
}

.controls {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 1rem;
  margin-bottom: 1.5rem;
}

.control-item {
  display: flex;
  flex-direction: column;
}

.control-item label {
  font-size: 0.9rem;
  margin-bottom: 0.3rem;
  color: #555;
}

.control-item input {
  padding: 0.4rem 0.5rem;
  border-radius: 5px;
  border: 1px solid #ccc;
}

.actions {
  display: flex;
  gap: 0.8rem;
  justify-content: center;
  margin-bottom: 1rem;
}

.actions button {
  padding: 0.6rem 1.2rem;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  background: #4caf50;
  color: white;
  font-weight: 500;
  transition: background 0.2s;
}

.actions button:disabled {
  background: #aaa;
  cursor: not-allowed;
}

.actions button:hover:not(:disabled) {
  background: #45a049;
}

.clear-btn {
  background: #f44336;
}

.clear-btn:hover {
  background: #d32f2f;
}

.server-response {
  background: #f0f0f0;
  padding: 0.8rem;
  border-radius: 6px;
  font-size: 0.9rem;
  color: #333;
  overflow-x: auto;
}
</style>
